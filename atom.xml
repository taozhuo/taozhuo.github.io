<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Zhuo's Blog]]></title>
  <link href="http://taozhuo.github.io/atom.xml" rel="self"/>
  <link href="http://taozhuo.github.io/"/>
  <updated>2017-01-08T22:27:02-08:00</updated>
  <id>http://taozhuo.github.io/</id>
  <author>
    <name><![CDATA[Zhuo Tao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bloom-filter Join in Spark]]></title>
    <link href="http://taozhuo.github.io/blog/2017/01/08/bloom-filter-join-in-spark/"/>
    <updated>2017-01-08T14:33:32-08:00</updated>
    <id>http://taozhuo.github.io/blog/2017/01/08/bloom-filter-join-in-spark</id>
    <content type="html"><![CDATA[<p>When it comes to join optimization techniques, map-side(broadcast) join is an obvious candidate. However it doesn&rsquo;t work when the data set is not small enough to fit into memory. But we can extend this approach if we find a representation of the data set that is small, e.g. a Bloom filter.</p>

<p>A Bloom filter is a space-efficient probabilistic data structure used to test whether a member is an element of a set(&lt;10 bits per element are required for a 1% false positive rate). Recently I ported a job from Apache Pig to Spark which gained significant speedup by using Bloom filter. This job joins 60 days of mobile-device pairs to cookies from a partner.</p>

<p>The optimized join goes like this: first build partial Bloom filters in each partition of smaller data, which can be done using <code>mapPartitions</code> in Spark. They are collected into driver node and merged into a full Bloom filter, which is then distributed to all executors and used to filter out large portions of the data that will not find a match when joined.</p>

<p>Implementation of Bloom filter in MapReduce is cumbersome in that you have to explicitly use <code>DistributedCache</code>, and write a lot of boilerplate code that handles file system I/O when writing it to HDFS and read it back later. Mapper(container) with only one cpu core is also inefficient when the filter is large. While <code>MultithreadedMapper</code> is possible, it&rsquo;s difficult to write code that is thread-safe. Spark&rsquo;s executor is a thread-pool by design, so you can easily assign many cpu cores to an executor. And Spark has a nice feature called Broadcast Variables that saves you a lot of effort, allowing you to distribute large data using efficient BitTorrent-like algorithms to reduce communication cost.</p>

<p>The good news is we don&rsquo;t need to write our own Bloom filter from scratch, instead we can use <code>org.apache.spark.util.sketch.BloomFilter</code> that is largely based on Google&rsquo;s Guava library. Under the hood it&rsquo;s a <code>long[]</code> representing a bit array, it has the advantage over other implementation in that the number of inserted bits can be larger than 4bn.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">org.apache.spark.util.sketch.BloomFilter</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//reading files</span>
</span><span class='line'><span class="k">val</span> <span class="n">bigRDD</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'><span class="k">val</span> <span class="n">smallRDD</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'><span class="k">val</span> <span class="n">cnt</span><span class="k">:</span><span class="kt">Long</span> <span class="o">=</span> <span class="n">smallRDD</span><span class="o">.</span><span class="n">count</span><span class="o">()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 1a. create bloom filters for smaller data locally on each partition</span>
</span><span class='line'><span class="c1">// 1b. merge them in driver</span>
</span><span class='line'><span class="k">val</span> <span class="n">bf</span> <span class="k">=</span> <span class="n">smallRDD</span><span class="o">.</span><span class="n">mapPartitions</span> <span class="o">{</span> <span class="n">iter</span> <span class="k">=&gt;</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">BloomFilter</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">cnt</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">)</span>  <span class="c1">//false positive probability=0.1</span>
</span><span class='line'>  <span class="n">iter</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">putString</span><span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="n">_1</span><span class="o">))</span>
</span><span class='line'>  <span class="nc">Iterator</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span><span class='line'><span class="o">}.</span><span class="n">reduce</span><span class="o">((</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">mergeInPlace</span><span class="o">(</span><span class="n">y</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 2. driver broadcasts bloom-filter</span>
</span><span class='line'><span class="n">sc</span><span class="o">.</span><span class="n">broadcast</span><span class="o">(</span><span class="n">bf</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 3. use bloom-filter to filter big data set</span>
</span><span class='line'><span class="k">val</span> <span class="n">filtered</span><span class="k">=</span> <span class="n">bigRDD</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">bf</span><span class="o">.</span><span class="n">mightContain</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">bf</span><span class="o">.</span><span class="n">mightContain</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">_2</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 4. join big data set and small data set</span>
</span><span class='line'><span class="n">filtered</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">smallRDD</span><span class="o">).</span><span class="n">saveAsTextFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>In order for this to run on the Hadoop cluster, we need to set sufficiently large memory on both driver and executors to hold the underlying bit array, depending on the value of false positive probability we&rsquo;ve set above. And we need to increase the maximum allowable size of Kryo serialization buffer, otherwise we&rsquo;ll see exceptions from Kryo:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">spark</span><span class="o">.</span><span class="n">kryoserializer</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">max</span>  <span class="mi">512</span><span class="n">m</span>
</span><span class='line'> <span class="o">--</span><span class="n">driver</span><span class="o">-</span><span class="n">memory</span> <span class="mi">100</span><span class="n">g</span> <span class="o">\</span>
</span><span class='line'> <span class="o">--</span><span class="n">driver</span><span class="o">-</span><span class="n">cores</span> <span class="mi">24</span> <span class="o">\</span>
</span><span class='line'> <span class="o">--</span><span class="n">num</span><span class="o">-</span><span class="n">executors</span> <span class="mi">130</span> <span class="o">\</span>
</span><span class='line'> <span class="o">--</span><span class="n">executor</span><span class="o">-</span><span class="n">memory</span> <span class="mi">50</span><span class="n">g</span> <span class="o">\</span>
</span><span class='line'> <span class="o">--</span><span class="n">executor</span><span class="o">-</span><span class="n">cores</span> <span class="mi">8</span> <span class="o">\</span>
</span></code></pre></td></tr></table></div></figure>


<p>I ran a test on the job I mentioned above. Simply counting the number of records in each stage shows >90% savings in shuffle size!</p>

<pre><code>Small data set: 244,071,770 records
Big data set: 42,504,945,562 records
After filtered: 1,587,344,750 records
After joined: 697,421,722 records
</code></pre>
]]></content>
  </entry>
  
</feed>
